# 贪婪算法：
## 1.分阶段工作，每个阶段所做决定最好：局部最优
## 2.调度问题：
### 1）一个处理器，多个作业，把平均完成时间最小化，一旦开始一个作业就必须运行完：应当将优先权赋予更短的作业
### 2）多处理器：假设作业有序，最短的先运行：按顺序开始作业，处理器间轮换分配。处理器个数能整除作业数时存在许多最优顺序。
## 3.文件压缩：
### 1）编码：
不同字符的代码长度变化不等，经常出现的字符代码短。代表字母的二进制代码可用二叉树表示，0代表左分支，1代表右分支，从根节点开始记录路径。最优的编码要令树是满树。
### 2）哈夫曼算法：
一棵树的权是树叶的频率的和，选有最小权的2棵树，任意形成以这两棵树为子树的新树，重复进行。有多少字符就有多少单节点树，这样在算法结束时得到一棵新树，是最优huffman编码树。此时，频率最小的字符一定是最深的节点，同深度节点字符交换不影响最优性。但是这需要先收集频率数据再进行编码。
## 4.近似装箱问题：
把大小不同的n件物品转到最小数量的箱子里，每个箱子容量为1单位，所有物品都小于1单位。
### 1）联机算法：
把每件物品放入箱子后才处理下一件，且不能改变决定。不存在最优算法。假设有个最优算法能把每个箱子放一个小项一个大项，小项和大项的和为1个单位，记序列1，则对序列2纯小项，就会将每个物品放一个箱子，造成浪费。联机算法至少使用4/3最优箱子数的输入
#### a）下项适合算法：
处理任何物品，查看是否能装进刚刚装进物品的同一个箱子，不能就开新箱子。最差会用到几乎2倍最优装箱数箱子
#### b）首次适合算法：
依序扫描箱子，把新的物品放入足以盛下的第一个箱子中，当先前放置物品的箱子没有余位才开新箱子。最差不会多于用到最优装箱数的17/10倍
#### c）最佳适合算法：
把物品放到能容纳它的最满的箱子，比起最优不会坏过1.7倍，对随机输入表现更好。
### 2)脱机算法
#### a)首次适合递减算法：输入数据已按大小排序。最优装箱方法用m个箱子。重量大于1/3的项会在前m个箱子内，外加的箱子中所有各项重量顶多1/3。假设放入外加箱子的物品至少m个，外加箱子中物品项数最多可以m-1,所用箱子数不超过(4m+1)/3。存在使首次适合递减法用到11/9个箱子的序列，所用箱子绝不超过（11/9m ）+4


# 1.二项队列（二叉堆））
## 1)二项树节点的秩是儿子节点个数：
Bk的根节点的秩为k，二项队列是堆序二项树的集合，对于任意的k，最多可以存在一棵二项树Bk(二项树不能秩相同)
## 2）合并二项队列：
存在0/1棵Bk，则作为一棵树放到合并后的二项队列，有2棵，就合并成B(k+1)树，如果有3棵，一棵直接放，剩下2棵合并后放。
## 3）位势函数：
数据结构在任何时候的状态由位势函数给出，该函数不由程序保存，是计数装置，将帮助进行分析。当操作花费少于我们允许它们使用的时间时，则没有用到的时间就以更高的位势存储起来。
## 4）对二项队列进行操作：
位势函数就是树的棵树，初始位势函数为0，且位势总是非负，因此摊还时间是实际时间的上界。

# 2.斜堆
## 1）合并斜堆：
将右路径合并成为新的左路径，对新路径每个节点出去最后一个，老左子树作为右子树依附（就是直接加到新斜堆，最后新斜堆的儿子不止2个）
## 2）最坏情形：
两个堆所有节点都位于右路径。
## 3）位势函数：
如果节点的右子树后裔数是占其后裔总数的一半，则该节点是重节点，否则为轻（后裔个数包括节点本身）。位势函数是堆中重节点的个数。
## 4）合并斜堆的摊还时间O(logN)
合并使右路径中的重节点一定变为轻节点，最坏情况是右路径的轻节点都变成重节点使卫视增加，把实际时间和位势变化加起来得到摊还界，可以推出摊还时间。

# 3.斐波那契堆
以O(1)摊还时间支持所有基本的堆操作的数据结构（如Insert,Merge,DecreaseKey），DeleteMin和Delete除外，这花费O(logN)摊还时间。
1）将第一次（因切除而）失去一个子节点的非根节点做上标记。
2）被标记节点又失去儿子，那么将该节点从父节点切除，使该节点变成分离的树并不被标记，叫一次级联切除
3）更改后会破坏堆序的节点也被切除。
4）标记节点是为了给任一节点的秩（子节点数）确定界，有n个后裔的任一节点的秩是O(logN)
5）树的棵数随级联切除而增加，所以要增加位势函数，要用位势的损失作为补偿。由于级联切除花费1单元时间并使位势+1，所以把每个标记的节点算2个位势，切除时就能消除一次级联切除次数。
# 4.二叉堆
## 1）DecreaseKey（切除节点）:
二叉堆中，降低元素的值，把元素向根节点上滤，直到建成堆序，最坏情形花费O(logN)，但优先队列的树不具O(logN)深度时，该方法不适用（如左式堆）
    将左式堆某个节点的值减低，上滤会引起堆序破坏，应将 堆切开，得到2棵树，再把这两棵树合并，此时如果2棵树都是左式堆，就可以以O(logN)合并，如果一个不是左式堆，就将其转变成左式堆（可以交换子节点做到）
## 2）懒惰合并：
需要合并时才合并堆，但并不实际把树结合在一起。可以把2个二项树的表连在一起得到新的二项队列，但可能含有相同大小的多棵树，破坏二项队列性质，所以称其为懒惰二项队列。这种操作总是花费最坏情形时间，一次插入通过创建一个单节点二项队列并将其合并而完成。DeleteMin需要我们将懒惰二项队列转变成标准二项队列。
## 3）DeleteMin:
需要我们将懒惰二项队列转变成标准二项队列（每个秩只有一棵树）。找出最小元素并删除，使其每个字节点成为新的树，再合并2棵相等大小的树，直至不能合并为止，把所有树合并成一个二项队列。（直接根节点相连就行）
## 4）懒惰二项队列的摊还分析：
与标准二项队列所用位势相同，是树的棵数，Merge,Insert的瘫痪运行时间都是O(1)，DeleteMin是O(logN)。总摊还时间是总运行时间的上界

# 5.伸展树
在节点X进行的任意树操作需要的时间正比于从根到x路径上的节点个数。单旋转记一次旋转，之字形和一字形记2次旋转，任何访问花费（1+旋转次数）。
1）秩一般是数的大小的对数的阶
2）对伸展树每次操作都需要依次展开，所以任意操作摊还时间是一次展开的摊还时间的常数倍数之内。可以采用节点的秩的和作为位势函数

